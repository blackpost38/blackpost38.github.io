<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dev Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blackpost38.github.io/"/>
  <updated>2019-04-04T11:27:27.804Z</updated>
  <id>https://blackpost38.github.io/</id>
  
  <author>
    <name>Hyunju Choi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Locust 사용 후기</title>
    <link href="https://blackpost38.github.io/2019/03/23/locust-review/"/>
    <id>https://blackpost38.github.io/2019/03/23/locust-review/</id>
    <published>2019-03-23T07:58:05.000Z</published>
    <updated>2019-04-04T11:27:27.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="목적"><a href="#목적" class="headerlink" title="목적"></a>목적</h2><p>최근 <strong>Locust</strong>를 이용해서 stress test를 한 후기를 남긴다.</p><h2 id="Locust-사용한-이유"><a href="#Locust-사용한-이유" class="headerlink" title="Locust 사용한 이유"></a>Locust 사용한 이유</h2><ul><li>시스템을 인수인계 받는 도중에 테스트에 대한 니즈가 생김<ul><li>API가 제대로 작동을 하는가?</li><li>어느 정도 부하를 견딜 수 있으며, 과도한 부하 상태에서 시스템은 어떤 행동을 하는가?</li></ul></li><li>어느 정도 부하를 견디는지 확인하기 위해 스트레스 테스트 툴을 검색하기 시작</li><li>JMeter, Grinder 등 많이 쓰이는 툴이 있었지만, Locust를 선택<ul><li>python으로 테스트 코드를 작성할 수 있다.</li><li>사용법이 간단하여, 금방 익힐 수 있다.</li></ul></li></ul><h2 id="Locust-사용-팁"><a href="#Locust-사용-팁" class="headerlink" title="Locust 사용 팁"></a>Locust 사용 팁</h2><ul><li>사용법은 단순하며, 문서보면 누구나 다 따라할 수 있는 수준<ul><li>Locust를 고른 이유이기도 함</li><li>때문에 사용법을 정리하기 보다는 팁을 남기는 것이 낫다고 판단</li></ul></li><li>다른 툴에 비해 낮은 RPS<ul><li>하나의 머신에서 수천명의 사용자의 행동을 시뮬레이션할 수 있도록 만들어진 툴</li><li>또한, python 코드로 사용자의 행동 시나리오를 만드는 것이 가능</li><li>따라서 단순 RPS 수치 측정 용도 보다는 위의 두 특징을 고려해서 Locust를 사용할 것인지 판단하는 것이 좋을듯</li><li>물론 적당한 RPS가 나오므로 큰 문제는 없다고 생각<ul><li>AWS 상에서 <code>t2.micro</code>를 사용했을때, 약 500 rps 정도가 나옴</li></ul></li></ul></li><li>멀티 코어 &amp; Docker를 사용해 Master&amp;Slave를 구축하면 성능을 최대한 끌어올릴 수 있다.<ul><li><code>docker-compose</code> 용 locust는 <a href="https://github.com/sernst/locusts" target="_blank" rel="noopener">sernst/locusts</a>을 사용했다.<ul><li>간단한 방법으로 Master와 Slave를 지정할 수 있다.</li></ul></li><li>그러나 극적인 효과는 없다 =&gt; <code>t2.micro</code>로 약 600 ~ 700 rps 정도가 나오는 수준</li><li>AWS를 사용하는 환경이라면, 여러 인스턴스로 Locust를 연결하면 퍼포먼스가 많이 오른다.<ul><li><code>t2.micro</code> 인스턴스를 15개 정도 연결 시켜서 7000 rps까지 찍어봤다.</li></ul></li><li>성능이 좋은 인스턴스를 여러 개 연결하더라도, 하나의 Locust만 실행하면 성능이 그렇게 좋아지진 않는다.<ul><li>4 core 짜리를 여러개 돌려봤는데 rps가 그렇게 좋아지지 않더라</li><li>알고보니 CPU를 하나만 소모하기 때문에 극적으로 퍼포먼스를 끌어올릴 수 없었던 것</li><li>Docker를 여러개 실행하여 CPU를 최대한 활용하는 것이 대안이 될 것</li></ul></li></ul></li><li>그런데 500 rps 정도면 왠만한 서비스의 부하 테스트는 가능하다는 생각<ul><li>실제로 테스트 대상이었던 시스템은 최대 100rps를 찍는 수준</li></ul></li><li>앞서 언급한 것보다 중요한건 시나리오 테스트 기능<ul><li>테스트 대상 시스템은 복잡한 기능이 없어 시나리오를 코드로 작성해서 테스트 해보진 않음</li><li>Locust의 강점은 코드로 어느 정도 사용자의 행동을 테스트할 수 있다는 것<ul><li>페이지 이동, 어떤 데이터 호출 등</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;목적&quot;&gt;&lt;a href=&quot;#목적&quot; class=&quot;headerlink&quot; title=&quot;목적&quot;&gt;&lt;/a&gt;목적&lt;/h2&gt;&lt;p&gt;최근 &lt;strong&gt;Locust&lt;/strong&gt;를 이용해서 stress test를 한 후기를 남긴다.&lt;/p&gt;
&lt;h2 id=&quot;L
      
    
    </summary>
    
    
      <category term="python, django, load test, stress test" scheme="https://blackpost38.github.io/tags/python-django-load-test-stress-test/"/>
    
  </entry>
  
  <entry>
    <title>react-common-component</title>
    <link href="https://blackpost38.github.io/2018/12/16/react-common-component/"/>
    <id>https://blackpost38.github.io/2018/12/16/react-common-component/</id>
    <published>2018-12-16T03:57:17.000Z</published>
    <updated>2019-03-23T07:48:16.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="공통-컴포넌트-설계-개발-및-적용"><a href="#공통-컴포넌트-설계-개발-및-적용" class="headerlink" title="공통 컴포넌트 설계, 개발 및 적용"></a>공통 컴포넌트 설계, 개발 및 적용</h2><p><a href="https://blackpost.xyz/2018/04/10/react-common-component/">이전 리액트 공통 컴포넌트</a> 글에서 공통 컴포넌트에 대한 생각을 정리한 적이 있습니다. 그 후 몇 개월이 지나서 실무에서 공통 컴포넌트를 만들고, 프로덕트에 적용할 기회가 생겼습니다. 그 경험을 정리하고자 합니다.</p><h2 id="느낀점"><a href="#느낀점" class="headerlink" title="느낀점"></a>느낀점</h2><p>느낀점 부터 말씀드리자면, 잘 설계된 공통 컴포넌트는 높은 생산성을 가져다 주었다는 겁니다. 같은 프로젝트에 참여한 팀원은 컴포넌트의 UI에 신경쓸 부분이 줄어들고 프론트 엔드 로직을 짜는데 집중을 할 수 있었습니다. 실제로 같은 수준의 화면의 UI를 잡는데 2, 3일 걸렸던 것이 반나절 만에 완성되기도 했습니다. (물론, 손에 익어서 더 빨라졌다 든지 같은 다른 요인도 있었을 겁니다.)</p><p>그 반대로 잘못 설계된 공통 컴포넌트는 오히려 손이 많이 가게 만드는 요인이 되기도 했습니다. 변경 사항이 올바르게 반영되었는지 확인하기 위해 이 공통 컴포넌트가 이미 적용된 곳을 하나씩 확인해야 했기 때문이었죠. 또한, 다른 프로젝트에서 느꼈 듯이 공통 컴포넌트가 너무 복잡하게 만들어지면, 사용하기 꺼려집니다. 너무 한정적으로 사용할 수 밖에 없어 활용도가 낮아지기 때문이지요.</p><p>다음 번에 공통 컴포넌트를 만드는 업무가 주어지면, 삽질을 덜 할 수 있다는 자신감을 심을 수 있었습니다.</p><h2 id="공통-컴포넌트-추출-작업"><a href="#공통-컴포넌트-추출-작업" class="headerlink" title="공통 컴포넌트 추출 작업"></a>공통 컴포넌트 추출 작업</h2><p>제가 작업했던 공통 컴포넌트는 크게 2가지 유형으로 나누는데, 대충 이름을 베이직(Basic)과 어드밴스드(Advanced)라고 하겠습니다.</p><p>UI 라이브러리를 React로 감싸는 수준의 컴포넌트들이 베이직에  속합니다. 이미 회사에서 사용하는 UI 라이브러리가 있어서 이를 React로 모두 감싸는 작업을 진행했죠. UI 라이브러리가 Semantic UI를 참고해서 만들어진 것이라, React를 감싸는 작업을 할때, React Semantic UI를 많이 참고했습니다.</p><p>어드밴스드 유형은 만드려는 프로덕트 내에서 반복되는 UI 패턴을 공통 컴포넌트로 추출한 것들 입니다. 파일 업로드 버튼이나, 폼 필드, 에디터 등이 이에 속하겠네요. 이런 유형의 컴포넌트들은 대부분 베이직에 속하는 공통 컴포넌트들의 조합으로 만들어 집니다.</p><h2 id="베이직-공통-컴포넌트-장-단점"><a href="#베이직-공통-컴포넌트-장-단점" class="headerlink" title="베이직 공통 컴포넌트 장/단점"></a>베이직 공통 컴포넌트 장/단점</h2><p>아무래도 작은 단위의 컴포넌트다 보니 유연하게 사용할 수 있고, 스타일을 덜 신경쓰면서 뚝딱뚝딱 만들어도 되는 장점이 있습니다. 실제로 인풋, 버튼 같은 각각의 엘리먼트에 스타일을 입힌 수준이니까요.</p><p>반면에 작은 단위의 컴포넌트를 만들어야 하다보니, 시간이 많이 든다는 장점이 있습니다만, 장점이 단점을 어느 정도 상쇄시켜 주는 것 같습니다.</p><h2 id="어드밴스드-공통-컴포넌트-장-단점"><a href="#어드밴스드-공통-컴포넌트-장-단점" class="headerlink" title="어드밴스드 공통 컴포넌트 장/단점"></a>어드밴스드 공통 컴포넌트 장/단점</h2><p>덩치가 큰 녀석들을 다루다 보니, 유연하게 사용할 수가 없습니다. 조금이라도 다른 요소가 필요해지면, <code>props</code>를 추가하고, <code>if</code>를 떡칠해가며 땜빵을 해야합니다. 이게 과해지면 결국엔 활용성이 떨어져 공통 컴포넌트로 쓰기가 꺼려지게 됩니다.</p><p>그래도 잘 만들어 두면, 생산성이 확 올라가더군요. 이거 하나만 보고 만드나 봅니다.</p><h2 id="어드밴스드-공통-컴포넌트-시행착오"><a href="#어드밴스드-공통-컴포넌트-시행착오" class="headerlink" title="어드밴스드 공통 컴포넌트 시행착오"></a>어드밴스드 공통 컴포넌트 시행착오</h2><p>기획서만 보고 섣불리 공통 컴포넌트로 뽑아내지 말자. 저는 능력도 경험도 부족했습니다. 섣불리 만들어 놓은 것들은 대대적인 수정 작업이 필요했고, 이미 적용해놓은 곳마다 하나하나 확인하는 작업이 커졌습니다.</p><p>우선 어떤 식으로 공통 컴포넌트를 뽑아낼 것인지 감을 잡아야 하는데 일단 저는 비슷하게 생긴 것들을 두 세개 개별적으로 만들어 보면서 감을 잡았습니다. 이런 식으로 작업하면서 공통 컴포넌트 2, 3개 정도 만들어 두었는데 굉장히 잘 쓰고 있습니다.</p><h2 id="도움이-되었던-것"><a href="#도움이-되었던-것" class="headerlink" title="도움이 되었던 것"></a>도움이 되었던 것</h2><ul><li><a href="https://react.semantic-ui.com/" target="_blank" rel="noopener">React Semantic UI</a>: 베이직 공통 컴포넌트는 모두 이것을 참조하여 만들었습니다. 이벤트 핸들러에서 <strong>lodash</strong>의 <code>invoke</code>를 사용하여 함수를 호출하는 것과 함수의 기타 파라미터로 자신의 <code>props</code>를 넘겨주는 것을 유용하게 써먹을 수 있었습니다.</li><li><a href="https://blog.risingstack.com/handling-react-forms-with-mobx-observables/" target="_blank" rel="noopener">Handling React Form With MobX Observables</a>: <strong>Form Field</strong>을 공통으로 추출할때 많이 참조하였습니다. 기본적인 아이디어는 <em>name</em>을 key로 사용하여 모델을 변경하게 만든다는 건데 굉장히 편합니다. 아마 Form 관련 라이브러리도 이런 원리로 실행되지 않을까 생각합니다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;공통-컴포넌트-설계-개발-및-적용&quot;&gt;&lt;a href=&quot;#공통-컴포넌트-설계-개발-및-적용&quot; class=&quot;headerlink&quot; title=&quot;공통 컴포넌트 설계, 개발 및 적용&quot;&gt;&lt;/a&gt;공통 컴포넌트 설계, 개발 및 적용&lt;/h2&gt;&lt;p&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="MERN" scheme="https://blackpost38.github.io/tags/MERN/"/>
    
      <category term="react" scheme="https://blackpost38.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>-Legacy- React UI Common Component</title>
    <link href="https://blackpost38.github.io/2018/04/10/lergacy-react-common-component/"/>
    <id>https://blackpost38.github.io/2018/04/10/lergacy-react-common-component/</id>
    <published>2018-04-10T03:56:39.000Z</published>
    <updated>2019-04-04T11:35:51.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UI-공통-컴포넌트-다시-생각해보기"><a href="#UI-공통-컴포넌트-다시-생각해보기" class="headerlink" title="UI 공통 컴포넌트 다시 생각해보기"></a>UI 공통 컴포넌트 다시 생각해보기</h2><ul><li>기술 면접 때, 공통 컴포넌트 개발과 관리에 대해 질문을 받았다.</li><li>당시 비용 관련해서 부정적인 측면만 말했는데, 정리를 안하고 말해서 좀 아쉬웠다.</li><li>그래서 다시 장단점을 정리해 보고, 만약 개발을 하게 된다면 이런 식으로 하면 좋을 것 같다고 계획을 세워봤다.</li></ul><h2 id="내가-생각하는-UI-공통-컴포넌트-장단점"><a href="#내가-생각하는-UI-공통-컴포넌트-장단점" class="headerlink" title="내가 생각하는 UI 공통 컴포넌트 장단점"></a>내가 생각하는 UI 공통 컴포넌트 장단점</h2><ul><li>장점<ul><li>재사용 가능<ul><li>하나의 컴포넌트가 여러 군데 사용됨</li><li>변경사항이 있어도 컴포넌트 하나만 고치면 된다.</li></ul></li></ul></li><li>단점<ul><li>비용<ul><li>컴포넌트의 공통 요소를 찾고 추출한 후 새로운 컴포넌트를 만들어야 한다.<ul><li>장기적으론 장점이 될 수도 있지만…</li></ul></li><li>잘 만들어야 한다.<ul><li>잘 만들어야 자주 사용한다.</li></ul></li><li>계속 관리도 해줘야 한다.<ul><li>공통인 만큼 나만 쓰는게 아니다.</li><li>변경이나 추가 사항이 있으면, 팀원들과 협의를 거쳐야 한다.</li></ul></li></ul></li></ul></li></ul><h2 id="새롭게-UI-공통-컴포넌트-개발한다면"><a href="#새롭게-UI-공통-컴포넌트-개발한다면" class="headerlink" title="새롭게 UI 공통 컴포넌트 개발한다면"></a>새롭게 UI 공통 컴포넌트 개발한다면</h2><ul><li>공통 컴포넌트를 베이직과 컴플렉스로 나누자.<ul><li>베이직은 말 그대로 기본 컴포넌트<ul><li>버튼, 모달, 폼 등</li><li>react-bootstrap 이나 matrial-ui의 컴포넌트를 참조해서 진행할 수 있을 것 같다.</li></ul></li><li>컴플렉스<ul><li>특정 정보에 맞게 여러 요소들이 조합되고 커스터마이징 된 컴포넌트: 테이블, 리스트, 차트, 확인창 등.</li><li>이 컴포넌트는 유연하지 않고, 특정 경우에만 제대로 동작하도록 만든다.</li></ul></li></ul></li><li>변경 사항이 있을 경우: 관리 측면<ul><li>베이직 컴포넌트의 경우 유연하게 만들어야 하므로 팀원들끼리 조율이 필요한 것 같다.<ul><li>state, props, event handler 등 합의를 거쳐서 기능을 변경하거나 추가하자.</li></ul></li><li>컴플렉스 컴포넌트 경우, 변경 사항에 맞추자.<ul><li>변경을 거듭하다가 공통 요소가 더이상 보이지 않을 경우 과감히 빼버리자.</li></ul></li><li>테스트는 꼼꼼히 하자.</li><li>비용은 감수하자.</li></ul></li></ul><blockquote><p>시간이 제한되어 있다면, 컴플렉스 컴포넌트만 관리하는 게 나을 것 같다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UI-공통-컴포넌트-다시-생각해보기&quot;&gt;&lt;a href=&quot;#UI-공통-컴포넌트-다시-생각해보기&quot; class=&quot;headerlink&quot; title=&quot;UI 공통 컴포넌트 다시 생각해보기&quot;&gt;&lt;/a&gt;UI 공통 컴포넌트 다시 생각해보기&lt;/h2&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="MERN" scheme="https://blackpost38.github.io/tags/MERN/"/>
    
      <category term="react" scheme="https://blackpost38.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>unable to find a live medium containing a live file system 에러 메시지</title>
    <link href="https://blackpost38.github.io/2018/01/20/unable-to-find-a-live-medium-containing-a-live-file-system-error-message/"/>
    <id>https://blackpost38.github.io/2018/01/20/unable-to-find-a-live-medium-containing-a-live-file-system-error-message/</id>
    <published>2018-01-20T11:20:54.000Z</published>
    <updated>2019-03-23T07:48:16.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="이슈"><a href="#이슈" class="headerlink" title="이슈"></a><a href="#이슈" title="이슈"></a>이슈</h1><h2 id="현상"><a href="#현상" class="headerlink" title="현상"></a><a href="#현상" title="현상"></a>현상</h2><ul><li>Ubuntu 16 설치 용 USB를 컴퓨터에 꽂고 인스톨을 하면 다음과 같은 에러 메시지가 뜬다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(initramfs) unable to find a live medium containing a live file system</span><br></pre></td></tr></table></figure></li></ul><h2 id="원인"><a href="#원인" class="headerlink" title="원인"></a><a href="#원인" title="원인"></a>원인</h2><ul><li>다양해서 파악하기 힘들다. (참조에서 살펴보자)</li></ul><h1 id="해결법"><a href="#해결법" class="headerlink" title="해결법"></a><a href="#해결법" title="해결법"></a>해결법</h1><ul><li>하나하나 원인이 될만한 것을 골라서 시도하는 수밖에 없는 것 같다.</li><li><p>그중에서 기존에 USB 3.0을 2.0으로 바꿔서 부팅 USB를 만드니 정상적으로 설치가 되었다.</p><pre><code>*   USB 포트에만 버전이 있는 줄 알았고, USB 자체에 버전이 있는 줄 몰랐다.</code></pre></li><li><p>실제로 시도했던 것들</p><pre><code>*   우분투 설치 파일 이미지에 문제가 있다고 생각해서 다시 다운로드 받음</code></pre><ul><li>USB 자체에 문제가 있다고 생각해서 다른 USB로도 만들어봄 (안타깝게도 둘 다 USB3.0이었다)</li><li>부팅 디스크를 만드는 소프트웨어에 문제가 있다고 가정</li></ul></li></ul><h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a><a href="#참조" title="참조"></a>참조</h1><ul><li><a href="https://forum.ubuntu-kr.org/viewtopic.php?t=27386" target="_blank" rel="noopener">에러 메시지 원인과 해결책 1</a>*   <a href="https://askubuntu.com/questions/15425/error-when-installing-unable-to-find-a-medium-containing-a-live-file-system" target="_blank" rel="noopener">에러 메시지 원인과 해결책 2</a></li><li><a href="http://tip.daum.net/question/89798349" target="_blank" rel="noopener">USB 2.0과 3.0 차이</a></li><li><a href="https://tutorials.ubuntu.com/tutorial/tutorial-create-a-usb-stick-on-macos" target="_blank" rel="noopener">Mac OS에서 Software로 Ubuntu 부팅 디스크 만들기</a></li><li><a href="http://sergeswin.com/1178" target="_blank" rel="noopener">Mac OS에서 CLI로 Ubuntu 부팅 디스크 만들기</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;이슈&quot;&gt;&lt;a href=&quot;#이슈&quot; class=&quot;headerlink&quot; title=&quot;이슈&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#이슈&quot; title=&quot;이슈&quot;&gt;&lt;/a&gt;이슈&lt;/h1&gt;&lt;h2 id=&quot;현상&quot;&gt;&lt;a href=&quot;#현상&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="DevOps" scheme="https://blackpost38.github.io/tags/DevOps/"/>
    
      <category term="Ubuntu" scheme="https://blackpost38.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>도커 컨테이너 끼리 통신</title>
    <link href="https://blackpost38.github.io/2018/01/13/networking-docker-container/"/>
    <id>https://blackpost38.github.io/2018/01/13/networking-docker-container/</id>
    <published>2018-01-13T12:18:05.000Z</published>
    <updated>2019-03-23T07:48:16.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="이슈"><a href="#이슈" class="headerlink" title="이슈"></a><a href="#이슈" title="이슈"></a>이슈</h1><h2 id="현상"><a href="#현상" class="headerlink" title="현상"></a><a href="#현상" title="현상"></a>현상</h2><ul><li>도커 컨테이너 끼리의 통신이 연결되지 않는다.</li></ul><h2 id="상황"><a href="#상황" class="headerlink" title="상황"></a><a href="#상황" title="상황"></a>상황</h2><ul><li>컨테이너 A에서 컨테이너 B의 API를 호출하고 싶다.</li><li>컨테이너 A는 localhost 3000 포트로 설정되어 있다.</li><li>컨테이너 B는 localhost 4000 포트로 설정되어 있다.</li><li>컨테이너 A에서 localhost 4000 포트로 Request를 보내면 응답하지 않는다.</li></ul><h2 id="원인"><a href="#원인" class="headerlink" title="원인"></a><a href="#원인" title="원인"></a>원인</h2><ul><li>도커 컨테이너가 자신의 localhost가 다른 의미를 갖게 된다.</li><li>도커 컨테이너의 IP를 살펴보면, <code>172.17.0.X</code> 같은 별도의 로컬 IP를 갖게 된다.</li><li>도커 컨테이너는 기본적으로 도커 네트워크 <strong>bridge</strong>에 속한다.</li><li>따라서 도커 컨테이너에서 localhost의 의미는 자기 자신의 컨테이너 IP를 가르키게 되버린다. (내 컴퓨터의 IP가 아닌!!)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker run -itd –name=container1 busybox</span><br><span class="line">&gt; docker run -itd –name=container2 busybox</span><br><span class="line">&gt; docker network inspect bridge</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line">&quot;Containers&quot;: &#123;</span><br><span class="line">  &quot;0f65120b94a56c26124322ce272b74657b46ad12176caa79a576c660b7c01864&quot;: &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;container1&quot;,</span><br><span class="line">      &quot;EndpointID&quot;: &quot;f71fd32ada7721d1412d0ceca764a6890e8902eaad1fd9bbfde39030ff717b89&quot;,</span><br><span class="line">      &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">      &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">      &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;13bf17f4b7fec846a71c15efdf3d7264ed289ff2f7b70c258ae4faaf567f6f5c&quot;: &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;container2&quot;,</span><br><span class="line">      &quot;EndpointID&quot;: &quot;a3379ded18d90c0e9d607982cda7b93a87951b0c042eb59a0c76fe59f31ce8fa&quot;,</span><br><span class="line">      &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">      &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,</span><br><span class="line">      &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">…</span><br></pre></td></tr></table></figure></li></ul><h1 id="해결법"><a href="#해결법" class="headerlink" title="해결법"></a><a href="#해결법" title="해결법"></a>해결법</h1><h2 id="도커-컨테이너-IP로-통신하기"><a href="#도커-컨테이너-IP로-통신하기" class="headerlink" title="도커 컨테이너 IP로 통신하기"></a><a href="#도커-컨테이너-IP로-통신하기" title="도커 컨테이너 IP로 통신하기"></a>도커 컨테이너 IP로 통신하기</h2><ul><li>도커 컨테이너끼리 기본적으로 bridge라는 동일한 도커 네트워크에 속해 있으므로 IP를 입력하여 통신할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker attach container1`</span><br><span class="line">&gt; ping 172.17.0.3</span><br><span class="line"></span><br><span class="line">PING 172.17.0.3 (172.17.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.3: seq=0 ttl=64 time=0.140 ms</span><br><span class="line">64 bytes from 172.17.0.3: seq=1 ttl=64 time=0.116 ms</span><br><span class="line">64 bytes from 172.17.0.3: seq=2 ttl=64 time=0.159 ms</span><br></pre></td></tr></table></figure></li><li><p>문제점은 도커 컨테이너가 재시작 되면 이 IP가 변경될 가능성이 있다.</p></li><li><p>언제든지 변경될 가능성이 생기기 때문에 웹 어플리케이션에 다이나믹한 IP를 설정하기엔 어려움이 있다.</p></li></ul><h2 id="도커-컨테이너-이름으로-통신하기"><a href="#도커-컨테이너-이름으로-통신하기" class="headerlink" title="도커 컨테이너 이름으로 통신하기"></a><a href="#도커-컨테이너-이름으로-통신하기" title="도커 컨테이너 이름으로 통신하기"></a>도커 컨테이너 이름으로 통신하기</h2><ul><li>도커 컨테이너 이름을 명시해서 통신하는 방법이 있다.</li><li>그러기 위해서 컨테이너를 시작할 때 <code>--link</code> 옵션을 사용한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker run –link container2:container2 -itd –name=container1 busybox</span><br><span class="line">&gt; docker attach container1</span><br><span class="line">&gt; ping container2</span><br><span class="line"></span><br><span class="line">PING container2 (172.21.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.21.0.3: seq=0 ttl=64 time=0.268 ms</span><br><span class="line">64 bytes from 172.21.0.3: seq=1 ttl=64 time=0.102 ms</span><br><span class="line">64 bytes from 172.21.0.3: seq=2 ttl=64 time=0.163 ms</span><br></pre></td></tr></table></figure></li><li><p><code>--link</code> 옵션을 추가하면 뭐가 달라질까?</p><ul><li>옵션 내용이 <code>/etc/hosts</code>에 반영된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker attach container1</span><br><span class="line">&gt; cat /etc/hosts</span><br><span class="line"></span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.17.0.2      container2 d759e0e85689</span><br><span class="line">172.17.0.3      87c4059eb3b6</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="알고보니-레거시-옵션"><a href="#알고보니-레거시-옵션" class="headerlink" title="알고보니 레거시 옵션"></a><a href="#알고보니-레거시-옵션" title="알고보니 레거시 옵션"></a>알고보니 레거시 옵션</h2><ul><li><code>--link</code> 옵션은 현재 레거시 옵션으로 분류되어 있으며 나중에 언제라도 없어질 수 있다.</li><li>도커 문서에서는 직접 네트워크를 정의하여 추가하는 방법을 제안한다.</li></ul><h2 id="유저-정의-네트워크"><a href="#유저-정의-네트워크" class="headerlink" title="유저 정의 네트워크"></a><a href="#유저-정의-네트워크" title="유저 정의 네트워크"></a>유저 정의 네트워크</h2><ul><li>bridge 네트워크 같은 도커 네트워크를 사용자가 직접 정의할 수 있다.</li><li><p>장점은 컨테이너 이름을 IP로 풀어주는 DNS가 자동으로 세팅된 다는 점이다.</p><pre><code>*   즉, 컨테이너 이름으로 통신이 가능하다는 것</code></pre></li><li>네트워크 정의한 후 도커 컨테이너 포함 시키기<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker network create my-network</span><br><span class="line">&gt; docker network connect my-network container1</span><br><span class="line">&gt; docker network connect my-network container2</span><br></pre></td></tr></table></figure></li><li>포함 시킨 후 container1에서 ping을 실행해보자<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker attach container1</span><br><span class="line">&gt; ping container2</span><br><span class="line"></span><br><span class="line">PING container2 (172.21.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.21.0.3: seq=0 ttl=64 time=0.268 ms</span><br><span class="line">64 bytes from 172.21.0.3: seq=1 ttl=64 time=0.102 ms</span><br><span class="line">64 bytes from 172.21.0.3: seq=2 ttl=64 time=0.163 ms</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;이슈&quot;&gt;&lt;a href=&quot;#이슈&quot; class=&quot;headerlink&quot; title=&quot;이슈&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#이슈&quot; title=&quot;이슈&quot;&gt;&lt;/a&gt;이슈&lt;/h1&gt;&lt;h2 id=&quot;현상&quot;&gt;&lt;a href=&quot;#현상&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="DevOps" scheme="https://blackpost38.github.io/tags/DevOps/"/>
    
      <category term="docker" scheme="https://blackpost38.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Array.sort 부적절한 예제</title>
    <link href="https://blackpost38.github.io/2018/01/13/array-sort-bad-example/"/>
    <id>https://blackpost38.github.io/2018/01/13/array-sort-bad-example/</id>
    <published>2018-01-13T12:18:04.000Z</published>
    <updated>2019-03-23T07:48:16.494Z</updated>
    
    <content type="html"><![CDATA[<p><code>Array.sort</code>는 파라미터로 <strong>compareFunction</strong>을 넘겨줄 수 있다.</p><p>compareFunction은 0, 음수 또는 양수를 리턴하면서 배열의 순서를 정해준다.</p><p>MDN에서 compareFunction 예제로 <code>function (a, b) { return a - b; }</code>를 봤다.</p><p>내가 이것을 이용한다고 아래와 같이 올바르지 않은 compareFunction을 작성한 적이 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function (a, b) &#123; return a &gt; b; &#125;</span><br></pre></td></tr></table></figure><p>위는 앞서 compareFunction을 설명했던 것과 달리 오로지 <code>true</code> 혹은 <code>false</code>를 반환한다.</p><p>따라서 이 boolean 값은 compareFunction의 리턴값으로 적절하지 못하다.</p><p><strong>문제는 이것이 알파벳 순 혹은 Ascending 형식으로 크롬에서 동작한다. 그리고 IE11에선 안된다.</strong></p><p>어떤 브라우저는 되고 안되고 해서 디버깅하기 까다로운 부분이므로 주의해야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Chrome</span><br><span class="line">[&apos;sub0&apos;, &apos;sub2&apos;, &apos;sub1&apos;].sort((a, b) =&gt; a &gt; b);  // [&apos;sub0&apos;, &apos;sub1&apos;, &apos;sub2&apos;]</span><br><span class="line"></span><br><span class="line">// IE11</span><br><span class="line">[&apos;sub0&apos;, &apos;sub2&apos;, &apos;sub1&apos;].sort((a, b) =&gt; a &gt; b);  // [&apos;sub0&apos;, &apos;sub2&apos;, &apos;sub1&apos;]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Array.sort&lt;/code&gt;는 파라미터로 &lt;strong&gt;compareFunction&lt;/strong&gt;을 넘겨줄 수 있다.&lt;/p&gt;
&lt;p&gt;compareFunction은 0, 음수 또는 양수를 리턴하면서 배열의 순서를 정해준다.&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Web Fundamental" scheme="https://blackpost38.github.io/tags/Web-Fundamental/"/>
    
      <category term="javascript" scheme="https://blackpost38.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>데이터를 Redux store 대신 React state에 저장해도 될까요?</title>
    <link href="https://blackpost38.github.io/2018/01/13/can-i-use-data-in-react-state-instead-of-redux-store/"/>
    <id>https://blackpost38.github.io/2018/01/13/can-i-use-data-in-react-state-instead-of-redux-store/</id>
    <published>2018-01-13T12:18:04.000Z</published>
    <updated>2019-03-23T07:48:16.494Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>아래 있는 이전 글을 <a href="https://www.facebook.com/groups/1413798668880301?id=1850080511918779" target="_blank" rel="noopener">react korea</a>에 공유하고 만족할 만한 피드백을 받았다.<br>여기에 피드백을 받고 생각이 바뀐 부분이 있어서 다시 정리하고자 한다. -원본은 멘 아래에 있다.-</p></blockquote><h2 id="모든-데이터를-Redux-store에-관리하려는-이유"><a href="#모든-데이터를-Redux-store에-관리하려는-이유" class="headerlink" title="모든 데이터를 Redux store에 관리하려는 이유"></a><a href="#모든-데이터를-Redux-store에-관리하려는-이유" title="모든 데이터를 Redux store에 관리하려는 이유"></a>모든 데이터를 Redux store에 관리하려는 이유</h2><p>처음 data를 Redux store에 관리할지 React state에 관리할지에 대한 내 생각은 아래와 같았다.</p><blockquote><p><em>데이터를 Redux store에 관리하는 것이 기본이다.</em><br><em>단, 어플리케이션 전반적으로 영향을 끼치지 않는 데이터는 React state로 두어도 괜찮다</em></p></blockquote><p>이유는 사용자 행동을 action으로 하나하나 정의하고 로깅으로 남겨두면, <strong>사용자 행동을 추적할 수 있어 디버깅이 편할 것 같았다.</strong></p><p>그래서 사용자의 action에 영향을 받는 모든 데이터를 Redux store로 관리하는 것이 기본이라고 생각했다.</p><h2 id="모든-데이터를-Redux-store에-관리하면-생기는-위험"><a href="#모든-데이터를-Redux-store에-관리하면-생기는-위험" class="headerlink" title="모든 데이터를 Redux store에 관리하면 생기는 위험"></a><a href="#모든-데이터를-Redux-store에-관리하면-생기는-위험" title="모든 데이터를 Redux store에 관리하면 생기는 위험"></a>모든 데이터를 Redux store에 관리하면 생기는 위험</h2><p>그런데 이러한 방식이 <strong>오히려 데이터 변경 이력을 지저분하게 만들 수 있다</strong>는 피드백을 받았다.</p><p>데이터 변경 이력에 대한 피드백을 곰곰이 생각해보니, 고객사에 가서 log를 뒤지던 나의 모습이 떠올랐다.</p><p>유의미한 log를 찾기 위해 무의미한 log를 수없이 필터링한 것이 기억이 났다.</p><p>이와 비슷하게 너무 많은 action이 정말로 중요한 action을 가릴 것 같은 생각이 들었다.</p><p>또한, <strong>퍼포먼스에 문제가 생길 수 있다</strong>는 의견도 받았다.</p><p>예를 들어, 폼을 입력하는 것까지 Redux로 관리하면 부하가 상당할 수도 있다는 내용이었다.</p><p>퍼포먼스와 관련된 내용은 <a href="http://redux.js.org/docs/faq/Performance.html#wont-calling-all-my-reducers-for-each-action-be-slow" target="_blank" rel="noopener">Redux 문서</a>에서 아래와 같이 안내하고 있어 별로 걱정하지 않았다.</p><ol><li>JavaScript engine의 충분히 좋은 성능</li><li>action이 dispatch 될 때 대부분 reducer는 default를 실행하므로 실질적으로 실행되는 코드는 적다는 것이었다.</li><li>만약 문제가 되면 패키지(redux-ignore)를 사용해서 특정 action에 특정 reducer만 작동하게끔 만들 수도 있다는 내용이었다.</li></ol><p>결국 문제가 되면 패키지를 이용해서 reducer를 커스터마이징 하라는 건데, 생각보다 많은 사람이 그 문제를 겪고 있는 것 같다.</p><p>그래서 action, reducer를 하나하나 정의해서 퍼포먼스 문제를 일으킬 가능성을 높히고, 커스터마이징 하는 수고까지 하기엔 비용이 굉장히 크다고 판단했다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a><a href="#결론" title="결론"></a>결론</h2><p>따라서 다시 정리한 내 생각은 아래와 같다.</p><p><em>되도록이면 지역적으로 사용하는 데이터는 React state로 관리하자.</em></p><p>생각 살짝 바꾸는게 이리 힘들 줄이야</p><blockquote><p><a href="http://redux.js.org/docs/faq/OrganizingState.html#do-i-have-to-put-all-my-state-into-redux-should-i-ever-use-reacts-setstate" target="_blank" rel="noopener">Q&amp;A</a>에 이와 같은 주제를 다룬 내용이 있다.</p></blockquote><hr><blockquote><p>여기서 부터 원본이다.</p></blockquote><p>Redux store에 데이터를 추가하는 일은 단순하면서도 귀찮은 작업이다.</p><p>Action, Reducer 그리고 Action을 dispatch 하는 곳 모두 수정해야 하기 때문이다.</p><p>때문에 번거로운 작업에서 벗어나기 위해 React state의 유혹을 받는다.</p><p>하지만 규모가 큰 React state를 관리하기 위해 Redux store를 사용하지 않던가…!</p><p><em>나는 Redux store 중에서 React state로 보관해도 문제가 없는 데이터에 대해 생각했다.</em></p><p><em>그리고 고민 끝에 지역적으로 사용하는 데이터는 React state로 사용해도 되겠다는 판단을 내렸다.</em></p><blockquote><p>중요한 것은 local state는 React state로 관리해야 한다가 아닌, 관리해도 된다는 것이다.</p></blockquote><p>여기서 지역적으로 사용한다는 것은 하나 또는 일부 컴포넌트 내에서만 사용하는 데이터이다.</p><p>비유하자면 데이터를 변수라고 가정하면, 지역 변수는 React state가 될 것이며, 전역 변수는 Redux Store가 될 것이다.</p><p>이 데이터의 특징은 Redux store로 굳이 관리하지 않아도, 어플리케이션 전반에 걸쳐 사용 되지 않고 일부에만 사용된다.</p><p>예를 들어, checkbox의 checked 데이터나 modal의 show/off 데이터는 해당 컴포넌트에만 사용된다.</p><p>따라서 이러한 데이터들은 React state로 관리해도 무방하다.</p><p>validation check가 필요한 input 컴포넌트의 데이터도 전반적으로 사용되는 것은 아니므로 React state로 관리해도 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;아래 있는 이전 글을 &lt;a href=&quot;https://www.facebook.com/groups/1413798668880301?id=1850080511918779&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;re
      
    
    </summary>
    
    
      <category term="MERN" scheme="https://blackpost38.github.io/tags/MERN/"/>
    
      <category term="react" scheme="https://blackpost38.github.io/tags/react/"/>
    
      <category term="redux" scheme="https://blackpost38.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx에 SSL 적용하기</title>
    <link href="https://blackpost38.github.io/2018/01/13/applying-ssl-to-nginx/"/>
    <id>https://blackpost38.github.io/2018/01/13/applying-ssl-to-nginx/</id>
    <published>2018-01-13T12:18:04.000Z</published>
    <updated>2019-03-23T07:48:16.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Let’s-Encrypt"><a href="#Let’s-Encrypt" class="headerlink" title="Let’s Encrypt"></a><a href="#Let’s-Encrypt" title="Let’s Encrypt"></a>Let’s Encrypt</h2><ul><li>Let’s Encrypt는 무료로 TLS/SSL 증명서를 제공해주고 설치해주는 인증기관(Certificate Authority)이다.</li><li>letsencrypt는 무료 TSL/SSL 증명서를 발급하기 위한 절차(process)를 간단하게 해주는 도구이다.</li><li>여기서 letsencrypt를 이용하여 SSL 증명서를 발급받고 자동으로 갱신하는 방법을 살펴보자.</li></ul><h2 id="시작하기-전"><a href="#시작하기-전" class="headerlink" title="시작하기 전"></a><a href="#시작하기-전" title="시작하기 전"></a>시작하기 전</h2><ul><li>도메인이 매핑되어 있는 nginx가 설치되어 있는 ubuntu</li><li>증명서를 발급할 때 도메인 이름으로 유효성 검증을 거친다.</li><li>서브 도메인에 매핑하고 싶으면 A record에 등록된 서브 도메인 이어야 한다.</li></ul><h2 id="letsencrypt-client-설치하기"><a href="#letsencrypt-client-설치하기" class="headerlink" title="letsencrypt client 설치하기"></a><a href="#letsencrypt-client-설치하기" title="letsencrypt client 설치하기"></a>letsencrypt client 설치하기</h2><ul><li>apt 패키지를 업데이트 하고 letsencrypt를 설치해보자.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo apt-get update</span><br><span class="line">&gt; sudo apt-get install letsencrypt</span><br></pre></td></tr></table></figure></li></ul><h2 id="SSL-증명서-얻기"><a href="#SSL-증명서-얻기" class="headerlink" title="SSL 증명서 얻기"></a><a href="#SSL-증명서-얻기" title="SSL 증명서 얻기"></a>SSL 증명서 얻기</h2><ul><li><p>플러그인 사용하기</p><pre><code>*   letsencrypt는 다양한 플러그인을 이용하여 SSL 인증서를 얻을 수 있다.</code></pre><ul><li>이 플러그인들은 서버에 인증서를 발급할지 여부만 따지므로 인증자(authenticators)라고도 한다.</li><li>여기서는 Webroot를 이용한다.</li><li>Webroot는 ./well-known 폴더에 특수한 파일을 놓고 작동한다.</li><li>따라서 nginx 설정을 변경하여 ./well-known 경로에 접근할 수 있도록 해준다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ /.well-known &#123;</span><br><span class="line">    allow all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>nginx 설정을 변경하였으니 설정이 맞게 되었는지 확인하고 설정을 적용하기 위해 nginx를 재시작을 해준다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; nginx -t</span><br><span class="line">&gt; systemctl restart nginx</span><br></pre></td></tr></table></figure></p></li><li><p>letsencrypt 명령어를 이용하여 인증서를 만들어 주자.</p><pre><code>*   `&amp;gt; letsencrypt -a webroot --webroot-path=/var/www/html -d blackpost.xyz`</code></pre><ul><li>-a: 우리가 사용할 plugin 이름</li><li>–webroot-path: /.well-known의 경로</li><li>-d: 도메인 이름</li><li><p>중간에 prompt가 나타나서 이메일과 동의 여부를 묻는다.</p><pre><code>*   이메일은 key 분실 시 필요한 정보이다.</code></pre><ul><li><p>letsencrypt로 4개의 .pem 파일이 만들어 진다.</p><pre><code>*   cert.pem: 도메인 인증서</code></pre><ul><li>chain.pem: letsencrypt 연결 인증서</li><li>fullchain.pem: cert.pem과 chain.pem이 결합된 인증서</li><li>privkey.pem: 인증서의 private key</li><li>/etc/letsencrypt/live/domain_name 경로에 링크가 되어 만들어 진다.</li></ul></li></ul></li></ul></li><li><p>보안 수준을 올리기 위해 strong diffie-hellman 그룹을 만들어 준다.</p><pre><code>*   `openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048`</code></pre><ul><li>/etc/ssl/certs/dhparam.pem 경로에 strong DH 그룹이 만들어진다.</li></ul></li></ul><h2 id="nginx에-TSL-SSL-설정하기"><a href="#nginx에-TSL-SSL-설정하기" class="headerlink" title="nginx에 TSL/SSL 설정하기"></a><a href="#nginx에-TSL-SSL-설정하기" title="nginx에 TSL/SSL 설정하기"></a>nginx에 TSL/SSL 설정하기</h2><ul><li><p>SSL 키와 인증서를 가르키는 설정 파일 만들기</p><pre><code>*   `nano /etc/nginx/snippets/ssl-blackpost.xyz.conf`</code></pre><ul><li>snippets 폴더에 conf 파일을 아래와 같은 내용으로 생성해준다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Strong encryption 세팅하기</p><pre><code>*   `nano /etc/nginx/snippets/ssl-params.conf`</code></pre><ul><li><p>ssl_dhparam 세팅 추가</p><pre><code>*   앞서 만들어준 strong diffie-hellman 그룹 경로 추가</code></pre></li><li><p>HTTP Strict Transport Security에 preload 기능 제거</p><pre><code>*   실수나 잘못 설정되어 있는 경우 광범위한 결과(?)를 초래할 수 있다.&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</code></pre><p><span class="line">2</span><br><td class="code"><pre><span class="line">add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot;;</span><br><span class="line">ssl_dhparam /etc/ssl/certs/dhparam.pem;</span><br></pre></td></p></li></ul></li><li><p>Nginx config 수정</p><pre><code>*   nginx config 파일을 연다.        *   `nano /etc/nginx/sites-available/default`</code></pre><ul><li>default에서 http request를 https request로 redirect를 시키기 위한 설정을 추가한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server;</span><br><span class="line">    server_name example.com <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a>;</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>바로 아래 https redirect 될 경우 적용할 server block을 만들어 준다.</p><pre><code>*   443 port를 사용하며 ssl 인증서를 사용하며, http2도 지원해준다.&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</code></pre><p><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # SSL configuration</span><br><span class="line">    listen 443 ssl http2 default_server;</span><br><span class="line">    listen [::]:443 ssl http2 default_server;</span><br><span class="line">    include snippets/ssl-example.com.conf;</span><br><span class="line">    include snippets/ssl-params.conf;</span><br><span class="line">. . .</span><br></pre></td></p></li><li><p>수정한 설정을 적용하기 위해 nginx 설정을 확인하고 재시작한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; nginx -t</span><br><span class="line">&gt; systemctl restart nginx</span><br></pre></td></tr></table></figure></p></li><li><p><a href="https://www.ssllabs.com/ssltest/analyze.html?d=example.com" target="_blank" rel="noopener">https://www.ssllabs.com/ssltest/analyze.html?d=example.com</a> 로 접속하여 적용한 SSL 레포트를 확인해 볼 수 있으며 A+가 나와야 한다.</p></li></ul><h2 id="인증서-자동-갱신"><a href="#인증서-자동-갱신" class="headerlink" title="인증서 자동 갱신"></a><a href="#인증서-자동-갱신" title="인증서 자동 갱신"></a>인증서 자동 갱신</h2><ul><li>인증서를 만들면 90 동안 유효기간이나 여유 있게 60일 정도 되면 갱신하는 게 좋다.</li><li>letsencrypt는 renew 커맨드를 제공해주며 인증서를 갱신해 준다.</li><li>만약 만기일이 30일 이하면 인증서를 갱신하나 그렇지 않으면, 만기일만 확인하고 끝난다.</li><li><p>실질적인 갱신 방법은 crontab에 갱신 작업을 등록하는 것이다.</p><pre><code>*   월요일에 한 번씩 갱신하도록 crontab에 작업을 추가하자.&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</code></pre><p><span class="line">2</span><br><span class="line">3</span><br><td class="code"><pre><span class="line">&gt; crontab -e</span><br><span class="line">30 2 <em> </em> 1 /usr/bin/letsencrypt renew &gt;&gt; /var/log/le-renew.log</span><br><span class="line">35 2 <em> </em> 1 /bin/systemctl reload nginx</span><br></pre></td></p></li></ul><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a><a href="#참고" title="참고"></a>참고</h2><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-16-04" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-16-04</a></li><li>port 80으로 설정되어야 letsencrypt certonly command가 에러 없이 실행된다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Let’s-Encrypt&quot;&gt;&lt;a href=&quot;#Let’s-Encrypt&quot; class=&quot;headerlink&quot; title=&quot;Let’s Encrypt&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#Let’s-Encrypt&quot; title=&quot;Let’s Encrypt&quot;&gt;
      
    
    </summary>
    
    
      <category term="Web Fundamental" scheme="https://blackpost38.github.io/tags/Web-Fundamental/"/>
    
      <category term="nginx" scheme="https://blackpost38.github.io/tags/nginx/"/>
    
      <category term="SSL" scheme="https://blackpost38.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>Nightwatch로 E2E 테스트 자동화 경험담</title>
    <link href="https://blackpost38.github.io/2018/01/13/experience-about-e2e-testing-with-nightwatch/"/>
    <id>https://blackpost38.github.io/2018/01/13/experience-about-e2e-testing-with-nightwatch/</id>
    <published>2018-01-13T12:18:04.000Z</published>
    <updated>2019-03-23T07:48:16.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="왜-테스트-해야-하는가"><a href="#왜-테스트-해야-하는가" class="headerlink" title="왜 테스트 해야 하는가?"></a><a href="#왜-테스트-해야-하는가" title="왜 테스트 해야 하는가?"></a>왜 테스트 해야 하는가?</h2><ul><li><p>새로운 비지니스를 준비해야 함.</p><pre><code>*   그런데 인력이 충분치 않음.</code></pre></li><li><p>그럼 어떻게 해야 할까?</p><pre><code>*   새로운 인력을 추가하거나 기존 인력이 하는 일을 더는 방법 밖에 없음.</code></pre><ul><li>새로운 인력을 추가하는 일은 이미 채용 공고를 올려 진행 중.</li></ul></li><li><p>기존 인력이 하는 일을 어떻게 덜까?</p><pre><code>*   반복되는 업무는 자동화를 시켜버리자.</code></pre></li><li><p>반복되는 업무는 뭐가 있을까?</p><pre><code>*   고객사 납품 직전에 제품을 테스트 하는 일 (이밖에도 많겠지만)</code></pre><ul><li>그래! 제품 테스트를 자동화 해보자</li></ul></li><li><p>제품 테스트는 어떻게 했었나?</p><pre><code>*   제품 테스트는 고객 요구사항이나 새로운 기능 위주로 테스트.</code></pre></li><li><p>여기서 문제점은 무엇인가?</p><pre><code>*   기존에 되던 기능들이 안되면 정말 난감.</code></pre><ul><li>만약 안 될 경우 기능 고치고 테스트하고 납품하는 일을 다시 한 번 해야함.</li><li>그렇다고 기존 기능까지 매번 반복해서 테스트 하는 것은 괴로운 일.</li></ul></li><li>올~ 제품 테스트 자동화 의미가 있는 것 같음. 한 번 해보자.</li></ul><h2 id="어떤-것을-테스트-할-것인가"><a href="#어떤-것을-테스트-할-것인가" class="headerlink" title="어떤 것을 테스트 할 것인가?"></a><a href="#어떤-것을-테스트-할-것인가" title="어떤 것을 테스트 할 것인가?"></a>어떤 것을 테스트 할 것인가?</h2><ul><li><p>‘최소한 이것은 테스트해야 된다’ 정도로 중요한 기능(주관적인 것이라…)을 테스트 하자.</p><pre><code>*   논의를 거쳐서 테스트할 기능을 쭉 리스팅했다.</code></pre><ul><li>그리고 기능을 토대로 테스트 시나리오 작성.</li></ul></li></ul><h2 id="어떻게-구현할-것인가"><a href="#어떻게-구현할-것인가" class="headerlink" title="어떻게 구현할 것인가?"></a><a href="#어떻게-구현할-것인가" title="어떻게 구현할 것인가?"></a>어떻게 구현할 것인가?</h2><ul><li>이미 우리는 Nightwatch를 이용하여 간단한 시나리오를 작성하고 E2E 테스트를 돌리고 있는 상태.</li><li>여기에 시나리오를 추가해서 앞서 리스팅한 내용을 모두 테스트할 수 있게 만들자.</li><li><p>E2E 테스트 코드를 작성할 때에는 아래를 항상 생각해보자.</p><pre><code>*   E2E 테스트의 기본을 지킨다.        *   E2E 테스트는 내부 구현을 고려하지 않고 오로지 기능을 테스트 하는 것이다.*   E2E 테스트는 UAT(user-acceptence-testing)이다.                *   UAT는 유저가 제품을 사용하는데 문제가 없는지를 테스트 하는 것이다.    *   예를 들어, 오탈자나 세세한 오작동은 신경쓰지 않고, 시스템이 깨지거나, 에러가 나서 더이상 진행을 할 수 없는 지를 테스트 한다.                        *   참고: [end-to-end-testing-with-nightwatch-js-node-js-at-scale](https://blog.risingstack.com/end-to-end-testing-with-nightwatch-js-node-js-at-scale)</code></pre><ul><li>코드는 읽기 쉬워야 한다.</li><li><p>모든 시나리오는 독립적으로 실행될 수 있다.</p><pre><code>*   시나리오가 다른 시나리오에 종속되면, 테스트 해보고 싶은 시나리오 하나 돌리는 것이 귀찮은 일이 된다.</code></pre><ul><li><p>그런데 막상 해보니 테스트 하고자 하는 기능에 선행되어야 하는 조건이 많은 경우가 있었다.</p><pre><code>*   스텝7을 테스트 하기 위해선 스텝1 ~ 6이 먼저 선행되는 것처럼…</code></pre></li><li>결국은 테스트 시나리오를 실행하기 전에, 테스트할 기능이 필요한 내용들을 미리 다 만들어 두는 시나리오를 따로 작성했다.</li></ul></li><li><p>하나의 시나리오는 하나의 목적만 갖는다 =&gt; 복잡하게 만들지 않는다.</p><pre><code>*   중간에 다른 길로 세지 않으려고…</code></pre></li><li><p>시나리오에서 만들어진 데이터는 제거한다.</p><pre><code>*   필요 없으니까!</code></pre></li><li><p>테스트를 위해 로직을 바꾸진 않는다.</p><pre><code>*   코드 자체를 바꾸고 싶진 않았지만, selector를 편하게 가져가기 위해 id를 꽤많이 추가했다.</code></pre></li></ul></li></ul><h2 id="구현하면서-도움이-되었던-것"><a href="#구현하면서-도움이-되었던-것" class="headerlink" title="구현하면서 도움이 되었던 것"></a><a href="#구현하면서-도움이-되었던-것" title="구현하면서 도움이 되었던 것"></a>구현하면서 도움이 되었던 것</h2><ul><li><p>E2E 테스트 범위 설정</p><pre><code>*   사용자가 어플리케이션 이용 목적에 해당되는 내용만 테스트 한다.</code></pre><ul><li>세세한 테스트는 유닛 테스트가 가져가야 할 문제.</li><li><p>만약 세세한 테스트 까지 작성하려면, 테스트 돌리는 시간과 이를 작성하는 비용이 굉장히 많이 든다.</p><pre><code>*   유닛테스트와 결합하여 사용할 수 있긴 하다. [unit-testing](http://nightwatchjs.org/guide#unit-testing)</code></pre></li></ul></li><li><p>페이지 오브젝트 활용</p><pre><code>*   페이지 별로 테스트를 구성할 수 있음.</code></pre><ul><li>페이지 오브젝트에 커맨드를 정의 하면 여러 시나리오에서 가져다 사용하기 편함.</li><li><p>시나리오를 작성할 때 사용자 중심으로 코드를 작성하는데 도움이 됨.</p><pre><code>*   페이지 오브젝트의 모든 커맨드 네이밍을 사용자 중심으로 함.</code></pre><ul><li><p>그 안의 내용은 Nightwatch의 API 같은 프로그래밍 요소를 사용하여 테스트를 실행.</p><pre><code>*   예를 들어, `.uploadDataSource` 커맨드를 선언함.</code></pre><ul><li>실제하는 일은 type이 file인 input 엘리먼트의 data 속성을 변경하는 일.</li></ul></li><li>이렇게 구성하면 시나리오 내용만 보고도 Nightwatch가 어떤 식으로 작동될지 예상할 수 있음.</li></ul></li><li><p>또한, 페이지 오브젝트에서 엘리먼트 또는 섹션을 제공해주는데, 복잡한 Selector를 어떠한 엘리먼트인지 정의할 수 있어서 코드 읽기가 수월해짐.</p><pre><code>*   실제로 `.someClass &amp;gt; div &amp;gt; span` 이런 것만 봐서는 어떤 엘리먼트인지 알기 어려움</code></pre><ul><li>엘리먼트나 섹션을 이용해서 <code>infoText: &amp;#39;.someClass &amp;gt; div &amp;gt; span&amp;#39;</code> 같이 정의해주는 것이 훨씬 명확함.</li><li>각 페이지마다 공통 되는 요소들(ProgressBar, Tab 등)은 Common 페이지를 하나 선언해서 공통적으로 사용할 수 있게 만들어 놓음.</li></ul></li><li>참고: <a href="http://nightwatchjs.org/guide#page-objects" target="_blank" rel="noopener">page-objects</a></li></ul></li><li><p>스크린샷 활용</p><pre><code>*   프로덕트의 중요한 화면의 경우는 직접 눈으로 보고 싶음 =&amp;gt; 눈으로 봐서 이상이 없는지도 확인하고 싶음.</code></pre><ul><li>이때 스크린샷 기능을 활용하면 도움이 됨.</li><li><p>특정 페이지로 가서 스크린샷 기능을 이용하여 원하는 이름으로 이미지 파일을 생성할 수 있음.</p><pre><code>*   현재 gitlab.ci E2E 파이프라인에서 E2E 테스트가 모두 끝나면, Docker를 이용하여 스크린샷들을 웹화면에서 볼 수 있게 세팅했음.</code></pre><ul><li>Docker image (image-gallery) 사용.</li></ul></li><li><p>참고</p><pre><code>*   [스크린샷](http://nightwatchjs.org/api/saveScreenshot.html)</code></pre><ul><li><a href="https://github.com/docwhat/docker-image-gallery" target="_blank" rel="noopener">Docker Image Gallery</a></li></ul></li></ul></li><li><p>Docker selenium에서 데이터 업로드 테스트</p><pre><code>*   여기서 삽질 꽤 많이 함.</code></pre><ul><li>Docker selenium을 이용하면 이상하게 파일 업로드가 되질 않았음.</li><li>해결법은 단순했음, volume을 이용하여 파일을 공유하면 되었음.</li><li><a href="https://github.com/nightwatchjs/nightwatch/issues/1064" target="_blank" rel="noopener">참고</a></li></ul></li><li><p>Gitlab Scheduled Pipeline</p><pre><code>*   E2E 테스트 파이프라인을 만들고, 매번 M.R 후에 돌리게 하니 시간을 상당히 잡아먹음. (45분 정도.)</code></pre><ul><li><p>이게 뭐가 문제가 되는데?</p><pre><code>*   (작업 성격 상) M.R이 수시로 일어남. =&amp;gt; 수시로 E2E 테스트가 실행 =&amp;gt; 45분 테스크가 수시로 실행</code></pre></li><li><p>그래서 E2E 테스트 파이프라인을 스케쥴링 해서 매일 새벽4시에 돌리게 만들어 놓음. (그냥 새벽에 돌려놓게 만듦)</p><pre><code>*   우리 솔루션은 수정되는 내용이 바로바로 고객사에 배포되는 것도 아님 =&amp;gt; 버그에 민감하게 반응하지 않아도 된다(?)</code></pre></li></ul></li></ul><h2 id="구현하고-나서-무엇이-달라졌는가"><a href="#구현하고-나서-무엇이-달라졌는가" class="headerlink" title="구현하고 나서 무엇이 달라졌는가?"></a><a href="#구현하고-나서-무엇이-달라졌는가" title="구현하고 나서 무엇이 달라졌는가?"></a>구현하고 나서 무엇이 달라졌는가?</h2><ul><li>피부로 와닿는 장점은 적어도 메인 기능을 이용하는데 어플리케이션이 깨지거나 버그가 생기는지 매일 확인할 수 있는 점.</li><li>그것도 사람이 아닌 소프트웨어가 자동으로…!</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;왜-테스트-해야-하는가&quot;&gt;&lt;a href=&quot;#왜-테스트-해야-하는가&quot; class=&quot;headerlink&quot; title=&quot;왜 테스트 해야 하는가?&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#왜-테스트-해야-하는가&quot; title=&quot;왜 테스트 해야 하는가?&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="MERN" scheme="https://blackpost38.github.io/tags/MERN/"/>
    
      <category term="nightwatch.js" scheme="https://blackpost38.github.io/tags/nightwatch-js/"/>
    
      <category term="node.js" scheme="https://blackpost38.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>Improving readability of your React component</title>
    <link href="https://blackpost38.github.io/2018/01/13/improving%20readability-of-your-react-component/"/>
    <id>https://blackpost38.github.io/2018/01/13/improving readability-of-your-react-component/</id>
    <published>2018-01-13T12:18:04.000Z</published>
    <updated>2019-03-23T07:48:16.494Z</updated>
    
    <content type="html"><![CDATA[<p>어느 정도 시간이 생겨 회사 솔루션에서 사용되는 React 컴포넌트 일부를 리팩토링 하기로 했다.</p><p>리팩토링으로 해결하고자 하는 큰 목적은 <strong>유지보수를 쉽게</strong>하는 것이었다.</p><p><em>그럼 어떻게 리팩토링을 할까? 어떻게 하면 유지보수가 쉬워질까?</em></p><p>결국 React 컴포넌트 뿐만 아니라 모든 소스 코드들이 그렇듯 <strong>가독성</strong>이 좋아지면 유지보수하기 쉬워지는 것 같다.</p><p>유지보수의 대부분이 에러 잡고, 기능 변경일 것이다.</p><p>이러한 업무를 맡으면 남이 짜놓은 소스 코드를 읽는 것은 피할 수 없다.</p><p>만약 내가 읽는 소스 코드가 복잡하면 절망감이 먼저 들며, 이해하는데 시간이 많이 걸린다.</p><p>그렇다면 어떻게 하면 React 컴포넌트의 가독성이 높아질까?</p><p>모르겠다. 그 방법을 알면 진작에 써먹었을 것이다. (젠장…)</p><p><em>그렇다면 현재 React 컴포넌트의 가독성을 떨어뜨리는 것들은 무엇인가?</em></p><p>차라리 이러한 요인을 제거해서 가독성을 높여 보자.</p><p><strong>React 컴포넌트에서 코드를 복잡하게 만드는 요인 중 하나는 너무 긴 JSX 코드인 것 같다.</strong></p><p>JSX 템플릿 코드가 많아지다 보니, 거기에 필요한 데이터 또는 이벤트 핸들러가 많아지면서 코드가 복잡해지는 것 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onClickFirst = () =&gt; &#123; /<em> … </em>/ &#125;</span><br><span class="line">onClickSecond = () =&gt; &#123; /<em> … </em>/ &#125;</span><br><span class="line">onClickThird = () =&gt; &#123; /<em> … </em>/ &#125;</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">  const someTransformedDataFirst = /<em> some logic that transforms data </em>/</span><br><span class="line">  const someTransformedDataSecond = /<em> some logic that transforms data </em>/</span><br><span class="line">  const someTransformedDataThird = /<em> some logic that transforms data </em>/</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div onClick=&#123;this.onClickFirst&#125;&gt;&#123;someTransformedDataFirst&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div onClick=&#123;this.onClickSecond&#125;&gt;&#123;someTransformedDataSecond&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div onClick=&#123;this.onClickThird&#125;&gt;&#123;someTransformedDataThird&#125;&lt;/div&gt;</span><br><span class="line">      /<em> … </em>/</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>그리고 다른 요인은 데이터를 JSX에 표시하기 위해서 변형하는 로직이다.</strong></p><p>이러한 로직이 <code>render</code> 메서드에 있다보니, 정작 React 컴포넌트가 어떤 형태의 UI인지 눈에 들어 오지 않고 스크롤 압박만 준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  const someData = this.props.someData;</span><br><span class="line">  const transformedData = /<em></em></span><br><span class="line">    some complex logic that transforms data</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">  /</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;&#123;transformedData&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>이 문제들의 공통점이 있다. 바로 <code>render</code> 메서드가 복잡하다는 것이다.</em></p><p>그러므로 <code>render</code> 메서드를 깔끔하게 만들면 가독성이 올라갈 것이다.</p><p><em>그럼 <code>render</code> 메서드를 어떻게 깔끔하게 만들까?</em></p><p><strong>JSX 코드가 너무 길어진다면 다른 컴포넌트로 추출해서 JSX 코드의 길이를 줄이는 방법이 있다.</strong></p><p>이것이 단지 코드 라인 수를 줄여 주는 것뿐만 아니라, 단순히 길었던 엘리먼트가 의미있는 컴포넌트로 대체되면서 가독성을 높여 준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;First someDataFirst=&#123;someDataFirst&#125; /&gt;</span><br><span class="line">      &lt;Second someDataFirst=&#123;someDataSecond&#125; /&gt;</span><br><span class="line">      &lt;Third someDataFirst=&#123;someDataThird&#125; /&gt;</span><br><span class="line">      /<em> … </em>/</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>파일 만들고, 새로운 컴포넌트 만들고, Props 옮겨주는 작업 귀찮은 거 알면서도… 그래도 그만큼 값어치 한다.</p><p>디버깅 할때 눈에 훨씬 잘들어 오고, 코드 읽기도 훨씬 편해진다. 한 번 수고하고 그 이후 유지보수 쉽게 가자.</p><p><strong>데이터를 변형하는 로직이 긴 경우엔 <code>render</code> 메서드 말고, <code>getter</code> 메서드 따로 선언해주고 그 안에 작성하자.</strong></p><p>그래야 <code>render</code>가 메인으로 하는 역할인 JSX 코드 리턴해주는 부분이 훨씬 눈에 잘 들어온다.</p><p><code>getter</code> 메서드 로직은 <code>render</code> 메서드가 어떻게 생긴지 보고 난 후에 봐도 늦지 않는다.</p><p>만약, <code>getter</code> 메서드가 다른 컴포넌트에서도 쓰인다면 <strong>selector</strong>를 별도로 만들어 주는 것도 생각해볼만 하다.</p><p>또한, <code>render*</code> 메서드를 활용해서 data 변형과 JSX를 리턴하는 로직을 같이 추출할 수도 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">getTransformedData = () =&gt; &#123;</span><br><span class="line">  const transformedData = /<em></em></span><br><span class="line">    some logic that transforms data</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">  /</span><br><span class="line">  return transformedData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">  const transformedData = this.getTransformedData();</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;&#123;transformedData&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 긴 내용을 요약하자면, React 컴포넌트의 가독성을 올리기 위해 <code>render</code> 메서드를 정리했다는 것이다.</p><p>그러면서 컴포넌트 내에 다른 메서드를 선언하여 로직을 추출하기도 했고, 아예 다른 컴포넌트를 만들어 추출하기도 했다.</p><p>끝으로 이 글에 대한 피드백이나, React 컴포넌트 가독성을 위해 고민했던 생각이나 다른 아티클이 있다면 댓글로 남겨주길 바란다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;어느 정도 시간이 생겨 회사 솔루션에서 사용되는 React 컴포넌트 일부를 리팩토링 하기로 했다.&lt;/p&gt;
&lt;p&gt;리팩토링으로 해결하고자 하는 큰 목적은 &lt;strong&gt;유지보수를 쉽게&lt;/strong&gt;하는 것이었다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;그럼 어떻게 리
      
    
    </summary>
    
    
      <category term="MERN" scheme="https://blackpost38.github.io/tags/MERN/"/>
    
      <category term="react" scheme="https://blackpost38.github.io/tags/react/"/>
    
  </entry>
  
</feed>
